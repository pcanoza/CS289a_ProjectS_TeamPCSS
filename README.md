# CS289a ProjectS TeamPCSS - Ancient Egypt's Ptolemy
## Group: Sankar Srinivasan, Philip Canoza

Final Project S for CS 289a at UC Berkeley.  The project repository contains Jupyter Python notebooks that use astronomical data and machine learning techniques to find parameters inspired by Ptolemy's epicycle model of the heavens. Data generated is from Team SKEP, see here: https://github.com/pnelson6679/projectS_early_deadline_teamSKEP . We hope this project provides insight on how we can use modern numerical methods to understand and generalize the theories of ancient civilizations.

## FFT
The FFT folder contains a Jupyter notebook, "Ptolemy_FFT.ipynb", that uses signal processing techniques to analyze the motions of celestial bodies, and ultimately to make predictions regarding positions and the occurrences of eclipses.

Section 1 performs cursory Fourier analyses of each of the celestial bodies' movements in the XY (ecliptic) plane, and is mostly for educational purposes. This section can be skipped if desired.

**Note:** The rest of the cells after Section 1 must be performed in order, or otherwise unexpected results (variable conflicts) may occur.

Section 2 defines three functions.
  1. "peak_finder" is used to determine the locations of peaks in spectral plots. Its only argument is a Numpy array of spectral magnitudes
  2. "XY_fft_optimizer" is the workhorse of this section. It uses "peak_finder", a range (start:step:end), a validation size, and the XY-coordinates of a celestial body in complex form. It loops through different choices of FFT window (from start:step:end) and for each window it identifies the top two frequencies (in magnitude) using  "peak_finder". With these two frequencies (and phase information from the Fourier Transform), it reconstructs a signal, which is then compared to the noisy data outside of the FFT window (validation set) of size "val_size". The FFT window size with the lowest mean squared error from this procedure is returned ("celestial_opt_length"), along with the best two frequencies from this particular FFT ("celestial_opt_freq_1", "celestial_opt_freq_2"). Note that these are not the raw frequencies, but indices used to index into the Numpy array generated by the FFT.
  3. "Z_fft_optimizer" is totally analogous to "XY_fft_optimizer", except it accepts a real valued z-coordinates of a celestial object.
  
  Throughout this section, optimal XYZ approximations for each of the celestial bodies are generated via the above functions--first the XY approximations, and then the Z approximations. At each step, plots are made to plot different flavors of training errors (with respect to noisy data).
  
Section 3 most importantly defines one function, used to make XYZ predictions for any object: "celestial_predict". It accepts as arguments the optimal FFT length and frequency indices outputed by the FFT optimizer functions in Section 2, as well as Numpy arrays corresponding to the timepoints of interest (where you want the forecast to be generated). Time 0 is defined as 1/1/1850, 00:00:00. From this point on, you can predict a time by using either a positive or negative number of days, hours, and minutes. For example: if you want to predict a body's position at one week from now and two weeks from now, your "days" array would be (7, 14), and your "hours" and "minutes" array would both be (0, 0). These three arrays all need to have the same length since they jointly describe the points in time where forecasts should be made.

Moreover, the MSE (mean squared error) as well as R-squared for the optimal XYZ approximations (now compared to test data, which is noiseless ground truth) are displayed.

Section 4 does not define a function, but attempts to do prediction for the solar/lunar eclipses. The predictions are limited to the time range of the dataset (1/1/1850 - 1/1/2000), but this can be updated by changing the Numpy array "full_domain" at the very top of the first cell in the section. (So if you wanted to predict starting from ten days before 1/1/1850 to ten days after 1/1/1850, you could set full_domain = np.arange(-10, 10, 1/144), where the step size of 1/144 corresponds to a step size of 10 minutes since there are 1440 minutes / day.)

Finally, Section 5 is to explore angular velocities of the different bodies. The main function used here is "reference_angular_velocities", which computes instantaneous angular velocities with respect to a reference point (1x2 Numpy array corresponding to (X,Y) point.) Accepts two Numpy arrays as argument, with "trajectory_x" corresponding to the trajectory of the object of interest in the X-axis and "trajectory_y" the Y-axis (must be the same length.) In the following cells, the instantaneous angular velocities of the 7 celestial bodies are plotted as a function of time, along with their spectral magnitudes.



## Regression
The regression folder contains a Jupyter notebook, regresssion_techniques.ipynb that uses linear regression techniques to learn positions of a geo-centric coordinate system of the heavens. The notebook also contains code for a simple regression to learn moon phases. Simply run the cells to perform the data-analysis.

## GIFs
Example GIFs to visualize the motion of the planets given this geocentric coordinate system and the epicycle model.  Also contained are examples of learned orbits.

## skep_data
CSV data generated from Team SKEPs early deadline project.
